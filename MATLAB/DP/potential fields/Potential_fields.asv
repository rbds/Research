%Potential Field Method

%%%%%%%%%Define a map with obstacles, start, and target locations
close all
figure(1)
hold on
clear


%create obstacles by code         
course = [0 0 45 33];
numberOfObstacles = 5;
s = [];
map = [];
% Draw Course    
obst = draw_obstacles(numberOfObstacles, course);

% Set Start and Goal locations
p_start = [5;28];
p_goal = [41; 6];

% Parameters 
param.res = 0.25;            %Resolution of intermediate points. Must be <0.25 for InCollision_Edge to run.
param.thresh = 12;           %Bias towards the goal starting at this distance
param.maxiters = 100;      %Cap on iterations to run RRT
param.RRTstarrad = 15;      %Maximum length of lines redrawn by RRT*
param.goalbias = .95;        %Probability of checking the goal as p_new
param.maxpathlength = 20;    %Maximum length of any path segment.
%param.smoothiters = 150;    %Number of iterations for smoothing algorithm
goal.r = .5;            %radius of goal
robot.r = 0.75;
robot.t = 0;

robot.p = p_start;               %set robot position to x_start

circle(p_start(1,1),p_start(2,1),goal.r,'g');               %draw the location of x_start and x_goal
circle(p_goal(1,1),p_goal(2,1),goal.r,'g');

ka = .2;
kr = .1;
%%%%%%%%%%%%%%while robot position != goal:

    %%%%%%%%%Define robot position

    %%%%%%%%%%%do a sensor sweep
    [ map, s ] = sensor( robot, obst, map, s);

    %%%%%%%%%%%Find potential function
        %attractive potential
        dU_a = ka*(robot.p - p_goal);
        plot([robot.p(1), robot.p(1)-dU_a(1)], [robot.p(2), robot.p(2)-dU_a(2)], 'g' )
   
        %repulsive potential
        d_to_obst = norm(-map(1).p + robot.p);
        dU_r = k_r*(0.5*(1./(d_to_obst*(-map(1).p + robot.p))) - 2
    %%%%%%%%%%%Find gradient

    %%%%%%%%%%%%Move robot for one timestep
